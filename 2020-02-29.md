## vue相关
### 1、v-for的key的作用？
- 1、v-for中的key值是为了优化diff算法，高效更新虚拟DOM，vue中列表循环需加上唯一标识的key，因为key可以表示组件的唯一性，提高组件的复用性。
- 2、在没有定义key的时候，会对v-for循环出来的元素有一定的影响，假设我们有一个操作，往循环的数组中添加某一项，diff算法会插入元素后的其余项重新进行渲染，这样渲染的效率会降低；如果我们定义了key值，往数组中添加某一项时，会根据key来进行diff算法，如果key值和标签没有改变，那么vue会就进行就地复用，这样就提高了diff算法效率。同时，我们还需要关注一个点就是key尽量不使用index,我们知道，改变循环的数组会改变其循环的index,如果用index作为key值，那么其实在往数组第一项添加元素时，index发生了改变，在进行diff算法的时候还是会重新渲染后面的元素。另外我们假设一个场景，我们循环的每一项前面有一个checkbox,我们选择第二项，然后在数组第一项前面添加一个元素，添加成功之后，此时checkbox选中的那一项值就是之前数组的第一项，这样就会造成数据混乱的局面。
- 3、一般情况下我们都会使用一个唯一的标识来当作key值，比如说id。但如果我们循环的数组时静态的，不会涉及到数组成员的改变，那么还是库用index来做key值的。
### 2、描述组件渲染和更新过程
- 1、渲染原理：vue编译器将template进行编译，生成一个render函数，当render函数调用时会进行渲染并同时返回一个虚拟DOM，之后通过patch函数将虚拟DOM施加到真实DOM上，在渲染的过程中，vue响应式的侦测所依赖的数据源，侦测到数据来源之后就可以精确的侦测数据变化，根据需要进行重新渲染，重新渲染之后会生成新树，将新树和旧树进行比对，就可以最终得出实施在DOM上的变动，通过patch函数进行更新。
- 2、vue的依赖追踪通过ES5的Object.defineProperty()来实现的，比如，我们给它一个原生对象，Vue会遍历这个数据对象的属性，然后进行属性变换，每一个属性都会被转换成一个getter和setter，同时每一个组件会有一个对应的watcher对象，这个对象的职责就是在当前组件被渲染的时候，记录数据上面的哪些属性被用到了。
- 3、例子：在渲染函数里面用到A.B的时候，这个就会触发对应的getter。整个渲染流程如下
    - 1、当某个数据被用到时，触发getter，这个属性就会被作为依赖被watcher对象记录下来；
    - 2、整个函数渲染完的时候，每一个被用到的属性都会被记录。
    - 3、相应的数据变动时，例如给他一个新值，就会触发setter，通知数据对象对应数据有改变；
    - 4、此时会通知对应的组件，其数据依赖有所改动，需要重新渲染；
    - 5、对应组件再次调用渲染函数，生成虚拟DOM，进而实现DOM更新。
### 3、组件中的data为什么是一个函数？为什么new Vue中data是一个对象而不是函数？
- 1、组件是可复用的vue实例，一个组件被创建好之后，是可以在多个地方进行复用的，组件中的data应该是分割开的，相互不影响的，基于这一理念，组件每复用一次，data的数据就应该被复制一次，之后，当某一处复用的组件内data数据被改变时，其他地方复用的组件的data不受影响，因此需要用一个函数来返回data，这样就能保证每一个组件中的data都是新创建的，不会相互影响；
- 2、在vue中，通过new Vue创建的只会创建一个根组件，只会用到一次，不会再其他地方再次被创建，因此不会存在data被影响的情况。
### 4、Vue中事件绑定
- 事件绑定的方法
    - v-on:click="handleClick"
    - @click="handleClick"
- 事件绑定的对象
    - 普通元素
    - 组件：如果在组件上绑定了事件，想要触发原生事件可以加.native修饰符
### 5、v-html会有什么问题？
- v-html用于在标签中插入html，并同时对插入的html进行解析，然后显示在页面上；v-text插入的时纯文本；
- 1、动态渲染html可能会非常危险，因为很容易导致XSS攻击，只能对可信内容使用html插值，绝不要对用户提供的内容进行插值；
    - 解决办法：使用<pre></pre>标签替换掉<div>标签，利用的就是<pre>的功能：被包围<pre>元素中的文本通常会保留空格和换行符，并且文本也会呈现为等宽字体
- 2、V-html更新的是元素的 innerHTML 。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。但有时我们需要渲染的html片段中有插值表达式，利用v-html插入到模板中显示是字符串。
    - 解决办法：使用组件来替代
- 3、在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。
    - 解决办法：1、照样使用scoped,使用深度选择器(>>>)，但是注意使用less和sass时此方法会失效
                2、写一个不带scope的全局style
### 6、v-model中是实现原理及如何自定义v-model

### 7、为什么要使用异步组件
- 理解：如果组件功能多打包结果会变大，可以采用异步的方式来加载组件，主要依赖import()这个语法，可以实现文件的分割加载
```
component:{
    MyComponent: (resolve)=>import("./components/MyComponent)
}
```
### 8、什么是作用域插槽？作用域插槽与普通插槽有什么区别？插槽有哪些？
- 理解：
    - 1、插槽：创建组件虚拟节点时，会将组件的子元素保存起来，当初始化组件时，通过插槽属性将子元素进行分类；渲染组件时会拿对应的slot属性的节点进行替换操作。（插槽的作用域为父组件）
    - 2、作用域插槽：作用域插槽在解析的适合，不会作为组件的孩子节点，会解析成函数，当子组件渲染时，会调用此函数进行渲染。（插槽的作用域为子组件）
### 9、谈谈你对keep-alive的理解
- 理解：keep-alive可以实现组件的缓存，当组件切换时不会对当前组件进行卸载，常用的2个属性（include,exclude）,2个生命周期（activated,deactivated）
### 10、Vue中常见的性能优化
- 1、编码优化
    - 1、不要将所有的数据都放在data中，data中的数据会增加getter和setter,会收集对应的watch
    - 2、vue在v-for时给每项元素绑定事件需要用事件代理
    - 3、SPA页面采用keep-alive组件
    - 4、拆分组件（提高复用性、增加代码的可维护性，减少不必要的渲染）
    - 5、v-if当值为false时内部指令不会执行，具有阻断功能，很多情况下使用v-if替代v-show
    - 6、key值保证唯一性（默认vue会采用就地复用策略）
    - 7、Object.freeze冻结数据
    - 8、合理使用路由懒加载、异步组件
    - 9、尽量采用runtime运行时版本
    - 10、数据持久化问题（防抖、节流）
- 2、Vue加载性能优化
    - 1、第三方模块按需导入（babel-plugin-component）
    - 2、滚动到可视区域动态加载（https://tangbc.github.io/vue-virtual-scroll-list）
    - 3、图片懒加载（https://github.com/hilongjw/vue-lazyload.git）
- 3、用户体验
    - 1、app-skeleton 骨架屏
    - 2、app-shell app壳
    - 3、PWA
- 4、SEO优化
    - 1、预渲染插件  prerender-spa-plugin
    - 2、服务端渲染ssr
- 5、打包优化
    - 1、使用cdn的方式加载第三方模块
    - 2、多线程打包 happypack
    - 3、splitChunk抽离公共插件
    - 4、sourceMap生成
- 6、缓存、压缩
    - 1、客户端缓存、服务端缓存
    - 2、服务端gzip压缩
### 11、Vue3.0中你知道有哪些改进
- 1、Vue3采用了TS来编写
- 2、支持Composition API
- 3、Vue3中响应式数据原理改成proxy
- 4、vdom的对比算法更新，只更新vdom的绑定了动态数据的部分
### 12、实现hash路由和history路由
### 13、Vue-Router中导航守卫有哪些？
### 14、action和mutation区别
### 15、简述vuex工作原理
### 16、数据双向绑定原理？双向绑定和vuex是否冲突？
### 17、vue中内置组件transition、transition-group的源码实现原理
### 18、说说patch函数里做了啥？
### 19、知道vue生命周期内部怎么实现的吗？
### 20、ssr项目中如果并发很大服务器性能怎么优化？
### 21、说下项目中怎么实现权限校验？
### 22、讲一下vue-lazyloader的原理，手写伪代码？
### 23、Vue.set的原理？
### 24、vue compile过程详细说一下，指令、插值表达式等vue语法如何生效的？
### 25、组件间通信方法
### 26、vue渲染原理
- 1、在vue1.0中，模板实现跟angular类似，把模板直接做成在浏览器里面parse成DOM树，然后去遍历这个树，提取其中的各种绑定；
- 2、在vue2.0中，引入了虚拟DOM的概念，其主要目的是减少原生DOM的操作，因为在浏览器中，javascript的运算在引擎中是非常快的，但是DOM本身是非常缓慢的东西，当调用原生DOM的时候，浏览器需要在javascript引擎的语境下去接触原生DOM的实现，这个过程是有相当的性能损耗的，所以本质的考量是，要把耗费时间的操作尽量放到纯粹的计算中去，保证涉及真实DOM的操作最少。vue2.0中的渲染过程是，vue编译器在编译模板之后，会返回一个渲染函数，而渲染函数被触发的时候就会进行渲染并返回一个虚拟DOM树，这个树非常轻量，主要是用来描述当前界面所应处的状态。当有了这个虚拟DOM树之后，就会交给一个patch函数，负责把这个虚拟DOM真正施加到真实DOM上。在这个过程中，vue有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源，在渲染过程中，侦测到数据来源之后，就可以精确感知数据源的变动，到时候可以根据需要重新进行渲染，当重新进行渲染之后，就会生成一个新的树，将新树和旧树进行对比，就可以最终得出实施在真实DOM上的改动，最后通过patch函数施加改动。
